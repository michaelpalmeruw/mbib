'''
implement batch processing tasks
'''

from config import config
import zipfile, os, sys, re, tempfile, shutil, glob
from collections import Counter

from auxfile import AuxFileParser


class Plumbing(object):
    '''
    delegate attribute lookup to coredb, acquire database, defer imports
    '''
    _db = _hub = _imex = None

    def dbfile(self):
        '''
        retrieve db file name without importing hub
        '''
        return os.path.realpath(os.getenv("mbib_db", None) or os.path.expanduser(config['paths']['dbfile']))

    def imex(self):
        if self._imex is None:
            from imex import Imex
            self._imex = Imex()
        return self._imex

    def hub(self):
        if self._hub is None:
            from hub import hub
            self._hub = hub
        return self._hub

    def db(self):
        if self._db is None:
            self._db = self.hub().sqlite
        return self._db

    def __getattr__(self, att):
        return getattr(self.hub().coredb, att)


class Jabrefy(Plumbing):
    '''
    take an ODT file and replace the citations generated by mbib with ones
    formatted for JabRef, so that JabRef can then format the bibliography.
    '''
    # some strings and regexes for mangling ODT files
    citation_match_re = re.compile(r'\<text:bibliography-mark [^\>]*text:identifier=\"(\w+)\"[^\<]*\<\/text:bibliography-mark\>', re.MULTILINE)
    citation_split_re = re.compile(r'(\<text:bibliography-mark [^\>]+\>[^\<]+\<\/text:bibliography-mark\>)', re.MULTILINE)

    empty_span_tags_re = re.compile(r'^\w*</text:span><text:span text:style-name="\w+">\w*$')
    existing_jr_keys_re = re.compile(r'(JR_cite\d*_\d*_([\w\_\-\:\,]+))')

    #replace_template = """<text:reference-mark-start text:name="{jrk}"/><text:span text:style-name="T1">[{ds}]</text:span><text:reference-mark-end text:name="{jrk}"/>"""

    # we simply do not apply any style name - that seems to work and should cause minimal
    # interference. We can always rig it up later if we feel the need.
    replace_template = """<text:reference-mark-start text:name="{jrk}"/><text:span>[{ds}]</text:span><text:reference-mark-end text:name="{jrk}"/>"""

    # can we drop the inner text:span tag entirely? Does Jabref still work in that case? No, it will then fail to merge
    # adjacent references.
    # replace_template = """<text:reference-mark-start text:name="{jrk}"/>[{ds}]<text:reference-mark-end text:name="{jrk}"/>"""

    # well, we can't just use T1 - it may be defined in ways that we don't want. So, we need to create our own style definition that is not otherwise used.
    # that means capturing all defined styles with a regex and then adding a new one. I guess we need to do this before we actually start replacing
    # the citation tags.
    # update - we no longer reference any style in the tags we introduce, so we can leave this be.
    # style_end_tag = "</office:automatic-styles>"
    # style_test_tag = """<style:style style:name="T1" style:family="text">"""  # we first test if it's there already.
    # extra_style_tag = """<style:style style:name="T1" style:family="text"><style:text-properties fo:language="zxx" fo:country="none"/></style:style>"""

    def __init__(self):
        self.bibtexkeys = set()     # collect keys found in mbib or existing JabRef citations
        self.jr_keys = set()        # collect JabRef-style citation keys - both existing and generated


    def get_cited_records(self):
        '''
        obtain full records for the collected bibtexkeys.
        '''
        stmt = '''
               select refs.*, reftypes.name as reftype
                      from refs, reftypes
                      where refs.reftype_id = reftypes.reftype_id
                      and refs.bibtexkey in (%s)
               '''
        base_records = self.db().execute_qmarks(stmt, [list(self.bibtexkeys)]).fetchall()
        full_records = self.hub().extend_refs(base_records)

        found = set([fr['bibtexkey'] for fr in full_records])
        missing = [k for k in self.bibtexkeys if not k in found]

        return missing, full_records


    def _get_citation(self, fragment):
        '''
        test if a text fragment represents a citation, and if so, return the bibtexkey it contains
        '''
        mo = self.citation_match_re.match(fragment)

        if mo is None:
            return None

        bibtexkey = mo.group(1)
        self.bibtexkeys.add(bibtexkey)

        return bibtexkey


    def format_group(self, group):
        '''
        format a group of citations as a JabRef citation group.

        we should strip out repetitions that might have snuck in,
        and I guess print a warning if that happens. We don't
        just use a set because we want to keep the sequence.
        '''
        filtered = Counter()

        for key in group:
            filtered[key] += 1

        keys = sorted(filtered.keys())

        repeated = [key for key, value in filtered.items() if value > 1]
        if repeated:
            print("dropping repetition of key(s) '%s' in same cite group" % ", ".join(repeated))

        tag_string = ','.join(keys)
        display_string = ", ".join(keys)

        template = "JR_cite{ctr}_1_{ts}"
        num = 0

        jr_key = template.format(ctr="", ts=tag_string)

        while jr_key in self.jr_keys:
            jr_key = template.format(ctr=num, ts=tag_string)
            num += 1

        self.jr_keys.add(jr_key)

        return self.replace_template.format(ts=tag_string, ds=display_string, jrk=jr_key)


    def _process_content(self, content):
        '''
        separate this from the unpacking and repacking. Return the modified string.
        '''
        # first, fish out any jabref citation keys that might already have been inserted manually.
        fragments = self.citation_split_re.split(content)
        # print("fragments", len(fragments))

        jr_keys = self.existing_jr_keys_re.finditer(content)

        for key in jr_keys:
            self.jr_keys.add(key.group())
            btkeys = key.group(2).split(',')
            self.bibtexkeys.update(btkeys)

        fragments = self.citation_split_re.split(content)

        # remove empties and empty pairs of closing and reopening text spans.
        # whitespace would have to be enclosed by citations and thus be spurious.
        filtered = [frag for frag in fragments if frag.strip() \
                         and not self.empty_span_tags_re.match(frag)]

        # insert an extra style tag into the preamble
        header = filtered[0]
        assert header.startswith('<?xml')

        # we no longer reference any style definition, so don't add one either
        #if not self.style_test_tag in header:
            #header = header.replace(self.style_end_tag, self.extra_style_tag + self.style_end_tag)
        rebuilt = [header]
        current_group = []

        for frag in filtered[1:]:
            citation = self._get_citation(frag)

            if citation is None:
                if current_group:
                    formatted = self.format_group(current_group)
                    rebuilt.append(formatted)
                current_group = []
                rebuilt.append(frag)
            else:
                current_group.append(citation)

        # the last fragment can never be a citation, so we don't need any explicit termination cleanup
        return len(fragments) - 1, "".join(rebuilt)


    def __call__(self):
        '''
        convert bibliography items in an odt file from native
        to jabref format
        '''
        infile_name = os.environ.get('mbib_target', None)
        db = self.dbfile()

        if infile_name is None:
            sys.exit('you must specify a target file name')

        trunk, ext = os.path.splitext(infile_name)
        outfile_name = "%s_jr%s" % (trunk, ext)

        full_outfile_name = outfile_name # os.path.join(curdir, outfile_name)
        clobber = os.getenv('mbib_clobber', False)

        if not clobber and os.path.exists(full_outfile_name) and \
            (os.stat(infile_name).st_mtime <= os.stat(full_outfile_name).st_mtime) and \
            (os.stat(db).st_mtime <= os.stat(full_outfile_name).st_mtime):
            sys.exit("File %s is up to date - exiting" % full_outfile_name)

        try:
            infile = zipfile.ZipFile(infile_name)
            content = infile.open('content.xml').read()
        except FileNotFoundError:
            sys.exit("file '%s' not found" % infile_name)
        except (KeyError, zipfile.BadZipFile):
            sys.exit("file '%s' has wrong type or is corrupt" % infile_name)

        # OK, at this stage, we have a valid input file.
        try:
            os.remove(full_outfile_name)
        except FileNotFoundError:
            pass

        mydir = tempfile.TemporaryDirectory(prefix="mbib_") # ()
        infile.extractall(mydir.name)

        curdir = os.path.realpath(os.getcwd())
        os.chdir(mydir.name)

        content = open('content.xml').read()
        num_cites, processed = self._process_content(content)

        if num_cites > 0:
            open('content.xml','w').write(processed)
            os.system('zip -r %s * > /dev/null' % outfile_name)
            shutil.move(outfile_name, full_outfile_name)
            print("wrote jabrefied file '%s'" % outfile_name)

        else:
            print("No mbib citations found, therefore not writing jabrefied .odt file")
            raise SystemExit

        os.chdir(curdir)
        missing, records = self.get_cited_records()

        if missing:
            print("Record(s) %s not found in database" % ", ".join(missing))

        if len(records) > 0:
            bibfile_name = os.path.splitext(outfile_name)[0] + '.bib'
            bibfile = open(bibfile_name, 'w')

            formatter = self.imex().format_bibtex

            for record in records:
                bibfile.write(formatter(record) + "\n\n")

            bibfile.close()
            print("wrote bibtex file '%s'" % bibfile_name)
        else:
            print("No citations retrieved from database, therefore not writing bibtex file")


class SyncBibtex(Plumbing):
    '''
    update a bibtex file to current state of database
    '''
    def __call__(self):
        '''
        synchronize database with default bibtex file. Come to think of it, we should
        probably check the file date on the core database and the bibtexfile.
        '''
        db = self.dbfile()
        bt = os.getenv('mbib_target') or config['paths']['bibtex_export']
        clobber = os.getenv('mbib_clobber', False)

        if not clobber and os.path.exists(bt) and \
            (os.stat(db).st_mtime <= os.stat(bt).st_mtime):
            sys.exit("File %s is up to date - exiting" % bt)

        folder_name = os.getenv('mbib_folder')

        if folder_name is None:
            refnode = self.special_branch_nodes['References']
            id_list = [refnode[1]]

        else:
            stmt = "select branch_id from branches where name = (?)"
            ids = self.db().execute(stmt, [folder_name]).fetchvalues()

            if len(ids) > 0:
                id_list = ids
            else:
                sys.exit("Database %s contains no folders named '%s'" % (db, folder_name))

        self.hub().export_bibtex(folder_ids=id_list, file_name=bt, batch=True)


class AuxExport(Plumbing):
    '''
    parse an aux file and generate the requested bib file on the fly.
    '''
    def append_ext(self, fn, ext):
        '''
        append default extension if file name has none
        '''
        frags = os.path.splitext(fn)
        if frags[1] == '':
            fn += ext
        return fn


    def __call__(self, run_bibtex=False):
        '''
        synchronize database with default bibtex file. Come to think of it, we should
        probably check the file date on the core database and the bibtexfile.
        '''
        auxfile = os.getenv('mbib_target')

        if auxfile is None:
            sys.exit('No aux file given')

        auxfile = self.append_ext(auxfile, '.aux')

        if not os.path.isfile(auxfile):
            sys.exit('aux file %s not found' % auxfile)

        parser = AuxFileParser()
        bibfile, citations = parser(auxfile)

        bibfile = self.append_ext(bibfile, '.bib')
        bibfile = os.path.realpath(bibfile)

        if len(citations) is None:
            sys.exit('found no citations in %s - exiting' % auxfile)

        # clobber = os.getenv('mbib_clobber', False)
        # we would have to parse both the bibtex file and the auxfile to know if
        # the bibfile is still up to date. More trouble than it's worth.

        self.hub().export_bibtex(ref_keys=citations, file_name=bibfile, batch=True)
        if run_bibtex:
            command = config['bibtex']['command']
            command = command.format(auxfile=os.path.basename(auxfile))
            os.system(command)


class BatchMode(object):

    def __init__(self, task):
        self.task = task

    def __call__(self):

        if self.task == 'jabrefy':
            Jabrefy()()

        elif self.task == 'sync':
            SyncBibtex()()

        elif self.task == 'auxexport':
            AuxExport()()

        elif self.task == 'auxbibtex':
            AuxExport()(True)

        else:
            sys.exit("don't know how command '%s'" % self.task)




